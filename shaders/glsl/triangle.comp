#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform image2D writeToImage;

struct HitRecord
{
  float _t;
  vec3 _point;
  vec3 _normal;
};

struct Sphere
{
  vec3 _center;
  float _radius;
};

struct Camera
{
  vec3 _lowerLeftCorner;
  vec3 _horizontal;
  vec3 _vertical;
  vec3 _origin;  
};

Camera camera =
  {
   vec3(-2.0, -1.0, -1.0),
   vec3(4.0, 0.0, 0.0),
   vec3(0.0, 2.0, 0.0),
   vec3(0.0, 0.0, 0.0),
  };

Sphere scene[] =
  {
   { vec3(0,-100.5, -1) , 100},
   { vec3(0,0,-1) , 0.5},
  };

struct Ray
{
  vec3 _origin;
  vec3 _direction;
};

vec3 evaluate(Ray ray, float t)
{
  return ray._origin + t*ray._direction;
}

bool hitSphere(Ray r, Sphere s, out HitRecord record)
{
  vec3 lineToSphere = r._origin - s._center;
  float a = dot(r._direction, r._direction);
  float b = 2.0 * dot(lineToSphere, r._direction);
  float c = dot(lineToSphere, lineToSphere) - s._radius*s._radius;
  float d = b*b - 4*a*c;

  if(d>=0) {
    float dist0 = (-b - sqrt(d)) / (2.0 * a);
    float dist1 = (-b + sqrt(d)) / (2.0 * a);
    float dist = min(dist0, dist1);
    if(dist<0)
      dist = max(dist0, dist1);
    if(dist<0)
      return false;
    record._t = dist;
    record._point = evaluate(r, dist);
    record._normal = (record._point - s._center)/s._radius; 
    
    return true;
  }
  return false;
}

float MAX_DIST = 1000000.0;

HitRecord hitWorld(Ray r)
{
  HitRecord currentRecord;
  currentRecord._t = MAX_DIST+1.0;
  uint numObjectsInScene = scene.length();

  for(uint i=0 ; i < numObjectsInScene ; i++) {
    HitRecord localRecord;
    localRecord._t = MAX_DIST+1.0;
    if(hitSphere(r, scene[i], localRecord) && localRecord._t<currentRecord._t) {
      currentRecord = localRecord;
    }
  }
  return currentRecord;
}

vec3 getColor(Ray r)
{
  HitRecord hit = hitWorld(r);
  if(hit._t > 0 && hit._t < MAX_DIST){
    return 0.5 * (hit._normal+vec3(1.0, 1.0, 1.0));
  }
  else {
    vec3 normDir = normalize(r._direction);
    float t = 0.5 * (normDir.y + 1.0);
    vec3 color = (1.0-t) * vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
    return color;
  }
  
}

// quick random, probably super repeating function
// just needed something that worked
float noise(float x)
{
  float v = fract(sin(x*0.59082409) *4151.2231);
  return v;
}

void main()
{
  
  ivec2 iSize = imageSize(writeToImage);

  uint aaSamplesPrPixel = 10;
  vec3 color = vec3(0,0,0);
  Ray ray;
  float xR=123123.12312;
  float yR=76785.431;
  for(uint sampleCount=0; sampleCount < aaSamplesPrPixel ; sampleCount++) {
    xR = noise(xR);
    yR = noise(yR);
    vec2 uv = (vec2(gl_GlobalInvocationID.xy) + vec2(xR, yR)) /vec2(iSize);

    ray._origin = camera._origin;
    ray._direction =
      camera._lowerLeftCorner+
      uv.x*camera._horizontal+
      uv.y*camera._vertical -
      camera._origin;
    color += getColor(ray);    
  }
  color = color / aaSamplesPrPixel;
  
  imageStore(writeToImage, ivec2(gl_GlobalInvocationID.xy), vec4(color.rgb, 1.0));
}
